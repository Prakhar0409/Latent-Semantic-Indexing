Perforce
Perforce is a commercial, proprietary revision control system developed by Perforce Software, Inc.

Perforce is a client/server system. The server manages a central database and a master repository of file versions. Users work on files in local client workspaces, and submit changed files together in changelists. Communication from client to the server is via any of a number of clients (user interfaces) (see below). Client and server communicate via TCP/IP using a proprietary RPC and streaming protocol.


The Perforce database is proprietary, preconfigured, and self-installed. It stores system-related metadata (file state, file attributes, branching and merging history, changelists, change descriptions, users, groups, labels, etc.). Files are identified by namespace (i.e., by OS-neutral filenames). File content itself is not stored in the database. MD5 hashes of file content are stored in the database, however, and can be used to verify repository file integrity.
Database tables are stored as binary files. Checkpoints and journals are written as text files that can be compressed and offloaded. A database that has been corrupted by hardware failure or other catastrophe can be recovered from the most recent journal and checkpoint. Administrators must plan for disaster recovery by configuring database journaling and setting up regular checkpoints.

Versioned file content is stored in a master directory hierarchy whose top levels are called "depots". Text file revisions are stored as RCS deltas[1] and binary file revisions are stored in their entirety. The encoding used for text files in the repository is either ASCII or Unicode, depending on Perforce server configuration. Repository files are not encrypted. Revisions that are branches or copies of other revisions are virtual copies within the repository. All revisions are preserved by default; limits can be set on the number of revisions preserved. Obsolete revisions and files can be purged by the administrator. Repository files must be included in regular system backups.

Clients to the Perforce system fall into roughly four categories: command, GUI, web, and plugin.
The basic command interface is P4, the command-line client. P4 can be used in any command shell or script. It produces human-readable output by default, but can also produce tagged text output, marshalled Python output, and marshalled Ruby output. A C++ API to the Perforce client commands is also available, as are Perl, Python, and Ruby extensions built upon it. The command interfaces support the system's complete client functionality and can be used with OS-native filename syntax as well as with Perforce's OS-neutral filename syntax.
Two GUI clients are available, the cross-platform, Qt-based P4V, and the Windows-only P4Win. Both support the majority of end-user operations. P4V also supports a subset of administrative operations.
A web interface is provided by P4Web,[2] a program that is both a Perforce client and a stand-alone HTTP daemon. P4Web can be run as a shared web server to provide read-only access to the Perforce file repository and metadata. It can also be run on a user's machine, enabling web browsers to become the interface to client operations on the local machine.
The plugin interfaces are behind-the-scenes programs that integrate Perforce client functionality into third-party software. Perforce plugins are available for desktop environments, software development tools, digital asset development tools, software build tools, code review systems, defect tracking systems, office automation tools, SQL clients, and FTP clients.


The Perforce system offers a hybrid of merge and lock concurrency models.[4] As with similar systems, users do not have to lock files in order to work on them and are required to resolve concurrent, committed changes before submitting their work. Users may optionally lock files to assure that they won't have to resolve concurrent changes.
However, the Perforce model is slightly different from those of similar systems in that users are expected to let the system know in advance which files they intend to change, even if they don't mean to lock them. Giving advanced notice puts files in a pending changelist that can be submitted to the server. It also enables the system to alert other users working on the same files. Thus users can tell when they are working in parallel and can take the opportunity to coordinate with one another before making changes that could otherwise be difficult to merge.
Perforce enforces this advanced notification requirement loosely by setting read-only permission on workspace files as it fetches them from the repository. Users can bypass the requirement, by choice or by necessity (when working offline, for example), simply by hijacking file permissions and modifying files as they see fit. It is up to the user, in these cases, to remember to use Perforce to reconcile offline work and put hijacked files in a pending changelist so they can be submitted. (It is also up to users to leave hijacked files writable after changing them. A read-only file that is not in a pending changelist is assumed by Perforce to be a candidate for update by replacement.)

A file is uniquely identified by its complete filename, e.g., //depot/trunk/src/item.cpp. Any non-deleted revision of a file can be branched. Perforce uses inter-file branching,[5] wherein branching creates a new file with a new name. For example, my/index.php may be branched into your/index.php and each file may then evolve independently. Repository paths are typically designated as containers for branched sets of files. For example, files in the //depot/trunk path may be branched as a set into a new //depot/rel1.0 path, resulting in two sets of files evolving independently and between which changes can be merged.
In Perforce the operation that merges changes from one branch to another is called integration. Integration propagates changes from a set of donor files into a set of corresponding target files; optional branch views can store customized donor-target mappings. By default, integration propagates all outstanding donor changes. Donor changes can be limited or cherry-picked by changelist, date, label, filename, or filename pattern-matching, The system records all integrations, uses them to select common ancestors for file merging, and does not by default perform redundant or unnecessary integrations.
Merging is actually only one of three possible outcomes of an integration. The others are ignoring (aka "blocking") and copying (aka "promoting"). Merging is used to keep one set of files up to date with another. For example, a development branch may be kept up to date with its trunk through repeated merging. Ignoring disqualifies changes in one set of files from future integration into another. It is often used when a development branch must be up to date with, and yet divergent from, its trunk. Copying is typically used to promote the content of an up-to-date development branch into a trunk.
Branching is also used to rename and move files. The user branches originals to new files, deletes the originals, and submits both the new files and the deletions together. A branched file is no different than an added file; branched files are peers, not offshoots, of their originals. The system keeps track of file origins, however, and refers to them when displaying the history of renamed files.

Perforce has two mechanisms for achieving distributed revision control; these mechanisms can be used independently or in combination. The first is a proxy server that caches frequently read versions in order to reduce file access times for remote users. This mechanism accommodates closed development organizations where a centrally controlled file repository and a universally accessible database are desired.
The second mechanism, known as remote depots, lets users connected to one server access file versions managed by other servers. With remote depots, each organization has control of its own server and makes parts or all of its repository visible to other servers. This mechanism is used for loosely coupled development organizations where a peer-to-peer approach is desired.

File access is controlled by one or more superusers. A range of file access permission levels can be granted. Permissions can be set for repository file paths, users, groups, and IP address subnets. The server can maintain an audit log of file access events for SOX and other compliance requirements. Perforce does not encrypt the file content or metadata it sends over the network. A tunneling protocol like VPN or SSH must be used to secure network transfers.
Security is controlled by the Perforce system administrator. Password strength is configurable; ticket-based authentication can be configured as well. Triggers (custom scripts or programs that run at predefined events) can be set on many but not all Perforce user commands and used to extend user authentication (with LDAP or SSO, for example), to block or allow user commands, and to constrain or normalize file modifications. Triggers are run by the Perforce server and do not have access to client machines or workspaces.

Free downloads of Perforce server, client, and plugin software are available from Perforce Software's website. The free version is a fully functional 2 user, 5 Workspace version of the software.
Server and client software is typically released twice a year[6] as pre-built executables for Microsoft Windows, Mac OS X, Linux, Solaris, FreeBSD, and other operating systems.

Use of the Perforce server is unrestricted for up to two users and five workspaces without a license. A license must be purchased for more users or workspaces. Free licenses are available for open source software development, school or classroom projects, and trial/evaluation periods. Use of Perforce client and plugin software is unrestricted, as is online access to Perforce technical documentation.

As of December 2007, Perforce is licensed to more than 250,000 users at 4,500 organizations.[7]



