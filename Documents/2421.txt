Apollo Guidance Computer
The Apollo Guidance Computer (AGC) was the first recognizably modern embedded system, used in real-time by astronaut pilots to collect and provide flight information, and to automatically control all of the navigational functions of the Apollo spacecraft. It was developed in the early 1960s for the Apollo program by the MIT Instrumentation Laboratory under Charles Stark Draper, with hardware design led by Eldon C. Hall. Based upon MIT documents, early architectural work seems to have come from J.H. Laning Jr., Albert Hopkins, Ramon Alonso,[1] and Hugh Blair-Smith.[2] The actual flight hardware was fabricated by Raytheon, whose Herb Thaler[3] was also on the architectural team.

Each flight to the Moon (with the exception of Apollo 8, which didn't take a Lunar Module on its lunar orbit mission) had two AGCs, one each in the command module and the lunar module. The AGC in the command module was at the center of that spacecraft's guidance & navigation system (G&C). The AGC in the Lunar Module ran its Primary Guidance, Navigation and Control System, called by the acronym PGNCS (pronounced pings).
Each lunar mission also had two additional computers:

The AGC formed the basis of an experimental fly-by-wire system installed into an F-8 Crusader to demonstrate the practicality of computer driven FBW system. The AGC used in the first phase of the program was replaced with another machine in the second phase, and research done on the program led to the development of FBW systems for the Space Shuttle. The AGC also led, albeit indirectly, to the development of FBW for the generation of fighters that were being developed at the time.[4]

The Apollo flight computer was the first to use integrated circuits (ICs). The Block I version used 4,100 ICs, each containing a single 3-input nor logic gate. The later Block II version used dual 3-input nor gates in a flat-pack, approximately 5,600 gates in all. The gates were made by Fairchild Semiconductor using resistor-transistor logic (RTL). They were interconnected by a technique called wire wrap, in which the circuits are pushed into sockets, the sockets have square posts, and wire is wrapped around the posts. The edges of the posts press against the wire with very high pressure, causing gas-tight connections that are more reliable than soldered PC boards. The wiring was then embedded in cast epoxy plastic. The decision to use a single IC design throughout the AGC avoided problems that plagued another early IC computer design, the Minuteman II guidance computer, which used a mix of diode-transistor logic (DTL) and diode logic (DL) gates made by Texas Instruments.
The computer's RAM was magnetic core memory (2 kibiwords) and ROM was implemented as core rope memory (36 kibiwords). Both had cycle times of 11.72 ms. The memory word length was 16 bits: 15 bits of data and 1 odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, 1 overflow bit, and 1 sign bit (ones' complement representation).

The user interface unit was called the Dsky.[5] Dsky stood for display and keyboard and was usually pronounced dis-key. It had an array of numeric displays and a calculator-style keyboard. Commands were entered numerically, as two-digit numbers: program, verb, and noun. The numerals were green high-voltage electroluminescent seven segment displays. The segments were driven by electromechanical relays, which limited the display update rate (Block II used faster silicon controlled rectifiers). Three 5-digit signed numbers could also be displayed in octal or decimal. These were typically used to display vectors such as space craft attitude or a required velocity change (delta-V). This calculator-style interface[nb 1] was the first of its kind, the prototype for all similar digital control panel interfaces.
The command module (CM) had two Dskys; one located on the main instrument panel and another located in the lower equipment bay near a sextant used for aligning the inertial guidance platform. Both Dskys were driven by the same AGC. The lunar module (LM) had a single Dsky for its AGC. A Flight Director Attitude Indicator (FDAI), controlled by the AGC, was located above the Dsky on the commander's console and on the LM.

The AGC was controlled by a 2.048 MHz crystal clock. The clock was divided by two to produce a four-phase 1.024 MHz clock which the AGC used to perform internal operations. The 1.024 MHz clock was also divided by two to produce a 512 kHz signal called the master frequency; this signal was used to synchronize external Apollo spacecraft systems.
The master frequency was further divided through a scaler, first by five using a ring counter to produce a 102.4 kHz signal. This was then divided by two through 17 successive stages called F1 (51.2 kHz) through F17 (0.78125 Hz). The F10 stage (100 Hz) was fed back into the AGC to increment the real-time clock and other involuntary counters using Pinc (discussed below). The F17 stage was used to intermittently run the AGC when it was operating in the standby mode.

The AGC had four 16-bit registers for general computational use. These were called the central registers:
There were also four locations in core memory, at addresses 20-23, dubbed editing locations because whatever was stored there would emerge shifted or rotated by one bit position, except for one that shifted right 7 bit positions, to extract one of the 7-bit interpretive op. codes that were packed 2 to a word. This was common to Block I and Block II AGCs.

The AGC had additional registers that were used internally in the course of operation. These were:

The instruction format was 3 bits for opcode, 12 bits for address. Block I had 11 instructions: TC, CCS, INDEX, XCH, CS, TS, AD, and MASK (basic), and SU, MP, and DV (extra). The first eight, called basic instructions, were directly accessed by the 3-bit op. code. The final three were denoted as extracode instructions because they were accessed by performing a special type of INDEX instruction (called EXTEND) immediately before the instruction.
The Block I AGC instructions consisted of the following:
Instructions were implemented in groups of 12 steps, called timing pulses. The timing pulses were named TP1 through TP12. Each set of 12 timing pulses was called an instruction subsequence. Simple instructions, such as TC, executed in a single subsequence of 12 pulses. More complex instructions required several subsequences. The multiply instruction (MP) used 8 subsequences: an initial one called MP0, followed by an MP1 subsequence which was repeated 6 times, and then terminated by an MP3 subsequence. This was reduced to 3 subsequences in Block II.
Each timing pulse in a subsequence could trigger up to 5 control pulses. The control pulses were the signals which did the actual work of the instruction, such as reading the contents of a register onto the bus, or writing data from the bus into a register.

Block I AGC memory was organized into 1 kibiword banks. The lowest bank (bank 0) was erasable memory (RAM). All banks above bank 0 were fixed memory (ROM). Each AGC instruction had a 12-bit address field. The lower bits (1-10) addressed the memory inside each bank. Bits 11 and 12 selected the bank: 00 selected the erasable memory bank; 01 selected the lowest bank (bank 1) of fixed memory; 10 selected the next one (bank 2); and 11 selected the Bank register that could be used to select any bank above 2. Banks 1 and 2 were called fixed-fixed memory, because they were always available, regardless of the contents of the Bank register. Banks 3 and above were called fixed-switchable because the selected bank was determined by the bank register.
The Block I AGC initially had 12 kibiwords of fixed memory, but this was later increased to 24 kibiwords. Block II had 32 kibiwords of fixed memory and 4 kibiwords of erasable memory.
The AGC transferred data to and from memory through the G register in a process called the memory cycle. The memory cycle took 12 timing pulses (11.72 Î¼s). The cycle began at timing pulse 1 (TP1) when the AGC loaded the memory address to be fetched into the S register. The memory hardware retrieved the data word from memory at the address specified by the S register. Words from erasable memory were deposited into the G register by timing pulse 6 (TP6); words from fixed memory were available by timing pulse 7. The retrieved memory word was then available in the G register for AGC access during timing pulses 7 through 10. After timing pulse 10, the data in the G register was written back to memory.
The AGC memory cycle occurred continuously during AGC operation. Instructions needing memory data had to access it during timing pulses 7-10. If the AGC changed the memory word in the G register, the changed word was written back to memory after timing pulse 10. In this way, data words cycled continuously from memory to the G register and then back again to memory.
The lower 15 bits of each memory word held AGC instructions or data. Each word protected by a 16th odd parity bit. This bit was set to 1 or 0 by a parity generator circuit so a count of the 1s in each memory word would always produce an odd number. A parity checking circuit tested the parity bit during each memory cycle; if the bit didn't match the expected value, the memory word was assumed to be corrupted and a parity alarm panel light was illuminated.

The AGC had five vectored interrupts:
The AGC responded to each interrupt by temporarily suspending the current program, executing a short interrupt service routine, and then resuming the interrupted program.
The AGC also had 20 involuntary counters. These were memory locations which functioned as up/down counters, or shift registers. The counters would increment, decrement, or shift in response to internal inputs. The increment (Pinc), decrement (Minc), or shift (Shinc) was handled by one subsequence of microinstructions inserted between any two regular instructions.
Interrupts could be triggered when the counters overflowed. The T3rupt and Dsrupt interrupts were produced when their counters, driven by a 100 Hz hardware clock, overflowed after executing many Pinc subsequences. The Uprupt interrupt was triggered after its counter, executing the Shinc subsequence, had shifted 16 bits of uplink data into the AGC.

The AGC had a power-saving mode controlled by a standby allowed switch. This mode turned off the AGC power, except for the 2.048 MHz clock and the scaler. The F17 signal from the scaler turned the AGC power and the AGC back on at 1.28 second intervals. In this mode, the AGC performed essential functions, checked the standby allowed switch, and, if still enabled, turned off the power and went back to sleep until the next F17 signal.
In the standby mode, the AGC slept most of the time; therefore it was not awake to perform the Pinc instruction needed to update the AGC's real time clock at 10 ms intervals. To compensate, one of the functions performed by the AGC each time it awoke in the standby mode was to update the real time clock by 1.28 seconds.
The standby mode was designed to reduce power by 5 to 10 W (from 70 W) during midcourse flight when the AGC was not needed. However, in practice, the AGC was left on during all phases of the mission and this feature was never used.

The AGC had a 16-bit read bus and a 16-bit write bus. Data from central registers (A, Q, Z, or LP), or other internal registers could be gated onto the read bus with a control signal. The read bus connected to the write bus through a non-inverting buffer, so any data appearing on the read bus also appeared on the write bus. Other control signals could copy write bus data back into the registers.
Data transfers worked like this: To move the address of the next instruction from the B register to the S register, an RB (read B) control signal was issued; this caused the address to move from register B to the read bus, and then to the write bus. A WS (write S) control signal moved the address from the write bus into the S register.
Several registers could be read onto the read bus simultaneously. When this occurred, data from each register was inclusive-ored onto the bus. This inclusive-or feature was used to implement the Mask instruction, which was a logical and operation. Because the AGC had no native ability to do a logical and, but could do a logical or through the bus and could complement (invert) data through the C register, De Morgan's theorem was used to implement the equivalent of a logical and. This was accomplished by inverting both operands, performing a logical or through the bus, and then inverting the result.

AGC software was written in AGC assembly language and stored on rope memory. There was a simple real-time operating system consisting of the Exec, a batch job-scheduling system that could run up to 8 'jobs' at a time using non-preemptive multi-tasking (each job had to periodically surrender control back to the Exec). There was also an interrupt-driven component called the Waitlist which could schedule multiple timer-driven 'tasks'. The tasks were short threads of execution which could reschedule themselves for re-execution on the Waitlist, or could kick off a longer operation by starting a 'job' with the Exec.
The Exec jobs were priority-based. The lowest priority job, called the dummy job, was always present. It did diagnostic checks and controlled a green computer activity light on the Dsky display: If the dummy job was running, this meant the computer had nothing better to do, so the light was turned off. The dummy job exited if there was some higher priority job to be done and this was indicated by the computer activity light being illuminated.
The AGC also had a sophisticated software interpreter that implemented a virtual machine with more complex and capable instructions than the native AGC. Interpreted code, which featured double precision scalar and vector arithmetic, even an MXV (matrix Ã— vector) instruction, could be mixed with native AGC code. The assembler and version control system, named YUL for an early prototype Christmas Computer, enforced proper transitions between native and interpreted code.
A set of interrupt-driven user interface routines called Pinball provided keyboard and display services for the jobs and tasks running on the AGC. A rich set of user-accessible routines were provided to let the operator (astronaut) display the contents of various memory locations in octal or decimal in groups of 1, 2, or 3 registers at a time. Monitor routines were provided so the operator could initiate a task to periodically redisplay the contents of certain memory locations. Jobs could be initiated. The Pinball routines performed the (very rough) equivalent of the UNIX shell.

