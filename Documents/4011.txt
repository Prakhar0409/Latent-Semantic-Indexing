Pascal (programming language)
Pascal is an influential imperative and procedural programming language, designed in 1968/9 and published in 1970 by Niklaus Wirth as a small and efficient language intended to encourage good programming practices using structured programming and data structuring.
A derivative known as Object Pascal was designed for object oriented programming.

Pascal is based on the ALGOL programming language and named in honor of the French mathematician and philosopher Blaise Pascal. Wirth subsequently developed the Modula-2 and Oberon, languages similar to Pascal. Before, and leading up to Pascal, Wirth developed the language Euler, followed by Algol-W.
Initially, Pascal was largely, but not exclusively, intended to teach students structured programming. Generations of students have used Pascal as an introductory language in undergraduate courses. Variants of Pascal have also frequently been used for everything from research projects to PC games and embedded systems. Newer Pascal compilers exist which are widely used.
Pascal was the primary high-level language used for development in the Apple Lisa, and in the early years of the Mac; parts of the original Macintosh operating system were hand-translated into Motorola 68000 assembly language from the Pascal sources. The popular typesetting system TeX by Donald E. Knuth was written in WEB, the original literate programming system, based on DEC PDP-10 Pascal, while an application like Total Commander was written in Delphi (i.e. Object Pascal).

Wirth's intention was to create an efficient language (regarding both compilation speed and generated code) based on so-called structured programming, a concept which had recently become popular. Pascal has its roots in the Algol 60 language, but also introduced concepts and mechanisms which (on top of Algol's scalars and arrays) enabled programmers to define their own complex (structured) datatypes, and also made it easier to build dynamic and recursive data structures such as lists, trees and graphs. Important features included for this were records, enumerations, subranges, dynamically allocated variables with associated pointers, and sets. To make this possible and meaningful, Pascal has a strong typing on all objects, which means that one type of data cannot be converted or interpreted as another without explicit conversions. Similar mechanisms are standard in many programming languages today. Other languages that influenced Pascal's development were COBOL, Simula 67, and Wirth's own Algol-W .
Pascal, like many scripting languages of today (but unlike most languages in the C family), allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside procedures and functions. This enables a very simple and coherent syntax where a complete program is syntactically nearly identical to a single procedure or function (except for the keyword itself, of course).

The first Pascal compiler was designed in Zurich for the CDC 6000 series mainframe computer family. Niklaus Wirth reports that a first attempt to implement it in Fortran in 1969 was unsuccessful due to Fortran's inadequacy to express complex data structures. The second attempt was formulated in the Pascal language itself and was operational by mid-1970. Many Pascal compilers since have been similarly self-hosting, that is, the compiler is itself written in Pascal, and the compiler is usually capable of recompiling itself when new features are added to the language, or when the compiler is to be ported to a new environment. The GNU Pascal compiler is one notable exception, being written in C.
The first successful port of the CDC Pascal compiler to another mainframe was completed by Welsh and Quinn at the QUB in 1972. The target was the ICL 1900 series. This compiler in turn was the parent of the Pascal compiler for the ICS Multum minicomputer. The Multum port was developed â€“ with a view to using Pascal as a systems programming language â€“ by Findlay, Cupples, Cavouras and Davis, working at the Department of Computing Science in Glasgow University. It is thought that Multum Pascal, which was completed in the summer of 1973, may have been the first 16-bit implementation.
A completely new compiler was completed by Welsh et al. at QUB in 1977. It offered a source-language diagnostic feature (incorporating profiling, tracing and type-aware formatted postmortem dumps) that was implemented by Findlay and Watt at Glasgow University. This implementation was ported in 1980 to the ICL 2900 series by a team based at Southampton University and Glasgow University. The Standard Pascal Model Implementation was also based on this compiler, having been adapted, by Welsh and Hay at Manchester University in 1984, to check rigorously for conformity to the BSI 6192/ISO 7185 Standard and to generate code for a portable abstract machine.
The first Pascal compiler written in North America was constructed at the University of Illinois under Donald B. Gillies for the PDP-11 and generated native machine code. Pascal enjoyed great popularity throughout the 1970s and the 1980s.
In order to rapidly propagate the language, a compiler "porting kit" was created in Zurich that included a compiler that generated code for a "virtual" stack machine (i.e. code that lends itself to reasonably efficient interpretation), along with an interpreter for that code - the Pascal-P system. Although the SC (Stack Computer) code was primarily intended to be compiled into true machine code, at least one system, the notable UCSD implementation, utilized it to create the interpretive UCSD p-System. The P-system compilers were termed P1-P4, with P1 being the first version, and P4 being the last to come from Zurich.
The P4 compiler/interpreter can still be run and compiled on systems compatible with original Pascal. However, it only itself accepts a subset of the Pascal language. A version of P4 that accepts the full Pascal language and includes ISO 7185 compatibility was created and termed the P5 compiler, which is available in source form.
A version of the P4 compiler, which created native binaries, was released for the IBM System/370 mainframe computer by the Australian Atomic Energy Commission; it was called the "AAEC Pascal Compiler" after the abbreviation of the name of the Commission. A version of P4 from 1975-6 including source and binaries for the compiler and run-time library files for the PDP-10 mainframe may be downloaded from this link.
In the early 1980s, Watcom Pascal was developed, also for the IBM System 370.
IP Pascal was an implementation of the Pascal programming language using Micropolis DOS, but was moved rapidly to CP/M running on the Z80. It was moved to the 80386 machine types in 1994, and exists today as Windows/XP and Linux implementations. In 2008, the system was brought up to a new level and the resulting language termed "Pascaline" (after Pascal's calculator). It includes objects, namespace controls, dynamic arrays, along with many other extensions, and generally features the same functionality and type protection as C#. It is the only such implementation which is also compatible with the original Pascal implementation (which is standardized as ISO 7185).
In the early 1980s, UCSD Pascal was ported to the Apple II and Apple III computers to provide a structured alternative to the BASIC interpreters that came with the machines.
Apple Computer created its own Lisa Pascal for the Lisa Workshop in 1982 and ported this compiler to the Apple Macintosh and MPW in 1985. In 1985 Larry Tesler, in consultation with Niklaus Wirth, defined Object Pascal and these extensions were incorporated in both the Lisa Pascal and Mac Pascal compilers.
In the 1980s Anders Hejlsberg wrote the Blue Label Pascal compiler for the Nascom-2. A reimplementation of this compiler for the IBM PC was marketed under the names Compas Pascal and PolyPascal before it was acquired by Borland. Renamed to Turbo Pascal it became hugely popular, thanks in part to an aggressive pricing strategy and in part to having one of the first full-screen Integrated development environments. Additionally, it was written and highly optimized entirely in assembly language, making it smaller and faster than much of the competition. In 1986 Anders ported Turbo Pascal to the Macintosh and incorporated Apple's Object Pascal extensions into Turbo Pascal. These extensions were then added back into the PC version of Turbo Pascal for version 5.5.
The inexpensive Borland compiler had a large influence on the Pascal community that began concentrating mainly on the IBM PC in the late 1980s. Many PC hobbyists in search of a structured replacement for BASIC used this product. It also began adoption by professional developers. Around the same time a number of concepts were imported from C in order to let Pascal programmers use the C-based API of Microsoft Windows directly. These extensions included null-terminated strings, pointer arithmetic, function pointers, an address-of operator and unsafe typecasts.
However, Borland later decided it wanted more elaborate object-oriented features, and started over in Delphi using the Object Pascal draft standard proposed by Apple as a basis. (This Apple draft is still not a formal standard.) The first versions of the Delphi Programming Language were accordingly named Object Pascal. The main additions compared to the older OOP extensions were a reference-based object model, virtual constructors and destructors, and properties. Several other compilers also implement this dialect.
Turbo Pascal, and other derivatives with units or module concepts are modular languages. However, it does not provide a nested module concept or qualified import and export of specific symbols.
Super Pascal was a variant which added non-numeric labels, a return statement and expressions as names of types.
The universities of Zurich, Karlsruhe and Wuppertal have developed an EXtension for Scientific Computing (Pascal XSC), which provides a free solution for programming numerical computations with controlled precision.
In 2005, at the Web 2.0 conference, Morfik Technology introduced a tool which allowed the development of Web applications entirely written in Morfik Pascal. Morfik Pascal is a dialect of Object Pascal, very close to Delphi.

Pascal, in its original form, is a purely procedural language and includes the traditional array of Algol-like control structures with reserved words such as if, then, else, while, for, and so on. However, Pascal also has many data structuring facilities and other abstractions which were not included in the original Algol60, like type definitions, records, pointers, enumerations, and sets. Such constructs were in part inherited or inspired from Simula67, Algol68, Niklaus Wirth's own AlgolW and suggestions by C. A. R. Hoare.

Pascal programs start with the program keyword with a list of external file descriptors as parameters; then follows the main statement block encapsulated by the begin and end keywords. Semicolons separate statements, and the full stop ends the whole program (or unit). Letter case is ignored in Pascal source. Some compilers, Turbo Pascal among them, have made the program keyword optional.
Here is an example of the source code in use for a very simple "Hello world" program:

A type in Pascal, and in several other popular programming languages, defines a variable in such a way that it defines a range of values which the variable is capable of storing, and it also defines a set of operations that are permissible to be performed on variables of that type. The types and a very brief description follows;

Pascal's simple (atomic) types are real, integer, character, boolean and enumerations, a new type constructor introduced with Pascal:
Subranges of any ordinal type (any simple type except real) can be made:
In contrast with other programming languages from its time, Pascal supports a set type:
A set is fundamental concept for modern mathematics, and they may be used in a great many algorithms. Such a feature is highly useful and may be faster than an equivalent construct in a language that does not support sets. For example, for many Pascal compilers:
is faster, than
Types can be defined from other types using type declarations:
Further, complex types can be constructed from simple types:
As shown in the example above, Pascal files are sequences of components. Every file has a buffer variable which is denoted by f^. The procedures get (for reading) and put (for writing) move the buffer variable to the next element. Read is introduced such that read(f, x) is the same as x:=f^; get(f);. Write is introduced such that write(f, x) is the same as f^ := x; put(f); The type text is predefined as file of char. While the buffer variable could be used to inspect the next character that would be used (check for a digit before reading an integer), this concept lead to serious problems with interactive programs with early implementations, but was solved later with the "lazy I/O" concept.
In Jensen & Wirth Pascal, strings are represented as packed arrays of chars; they therefore have fixed length and are usually space-padded. Some dialects have a custom string type.

Pascal supports the use of pointers:
Here the variable pointertob is a pointer to the data type b, a record. Pointers can be used before they are declared. This is a forward declaration, an exception to the rule that things must be declared before they are used. To create a new record and assign the value 10 and character A to the fields a and b in the record, and to initialise the pointer c to nil, the commands would be:
This could also be done using the with statement, as follows
Inside of the scope of the with statement, a and b refer to the subfields of the record pointer pointertob and not to the record b or the pointer type a.
Linked lists, stacks and queues can be created by including a pointer type field (c) in the record (see also nil and null (computer programming)).

Pascal is a structured programming language, meaning that the flow of control is structured into standard statements, ideally without 'go to' commands.

