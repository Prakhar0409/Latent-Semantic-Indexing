VirtualGL
VirtualGL is an open source program which redirects the 3D rendering commands from Unix and Linux OpenGL applications to 3D accelerator hardware in a dedicated server and displays the rendered output interactively to a thin client located elsewhere on the network.

Normally, VNC and other thin client environments for Unix and Linux either do not support running OpenGL applications at all or force the OpenGL applications to be rendered without the benefit of OpenGL hardware acceleration. Remotely displaying 3D applications with hardware acceleration has traditionally required the use of "indirect rendering." Indirect rendering uses the GLX extension to the X Window System ("X11" or "X") to encapsulate the OpenGL commands inside of the X11 protocol stream and ship them from an application to an X display. Traditionally, the application runs on a remotely-located application server, and the X display runs on the user's desktop. In this scenario, all of the OpenGL commands are executed by the user's desktop machine, so that machine must have a fast 3D graphics accelerator. This limits the type of machine that can remotely display a 3D application using this method.
Indirect rendering can be shown to perform well if the network is sufficiently fast (gigabit ethernet, for instance), if the application does not dynamically modify the geometry of the object being rendered, if the application uses display lists, and if the application does not use a great deal of texture mapping. Many OpenGL applications, however, do not meet these criteria. To further complicate matters, some OpenGL extensions do not work in an indirect rendering environment. Some of these extensions require the ability to directly access the 3D graphics hardware and thus can never be made to work indirectly. In other cases, the user's X display may not provide explicit support for a needed OpenGL extension, or the extension may rely on a specific hardware configuration that is not present on the user's desktop machine.
Performing OpenGL rendering on the application server circumvents the issues introduced by indirect rendering, since the application now has a fast and direct path to the 3D rendering hardware. If the 3D rendering occurs on the application server, then only the resulting 2D images must be sent to the user's desktop. Images can be delivered at the same frame rate regardless of how big the 3D data was that was used to generate them, so performing 3D rendering on the application server effectively converts the 3D performance problem into a 2D performance problem. The problem then becomes how to stream 1-2 megapixels of image data over a network at interactive frame rates, but commodity technologies (HDTV, to name one) already address this problem.

VirtualGL uses "GLX forking" to perform OpenGL rendering on the application server. Unix and Linux OpenGL applications normally send both GLX commands and ordinary X11 commands to the same X display. The GLX commands are used to bind OpenGL rendering contexts to a particular X window, obtain a list of pixel formats that the X display supports, etc. VirtualGL takes advantage of a feature in Unix and Linux that allows one to "preload" a library into an application, effectively intercepting (AKA "interposing") certain function calls that the application would normally make to shared libraries with which it is linked. Once VirtualGL is preloaded into a Unix or Linux OpenGL application, it intercepts the GLX function calls from the application and rewrites them such that the corresponding GLX commands are sent to the application server's X display, which presumably has a 3D hardware accelerator attached. Thus, VirtualGL prevents GLX commands from being sent over the network to the user's X display or to a virtual X display ("X proxy"), such as VNC, that does not support GLX. In the process of rewriting the GLX calls, VirtualGL also redirects the OpenGL rendering into off-screen pixel buffers ("Pbuffers.") Meanwhile, the rest of the function calls from the application, including the ordinary X11 commands used to draw the application's user interface, are allowed to pass through VirtualGL without modification.
Internally, VirtualGL's interposer engine also maintains a map of windows to Pbuffers, matches visual attributes between the destination X display and the X display on which the 3D rendering will occur, and performs a variety of other hashing functions to assure that the GLX redirection is seamless. But essentially, once the OpenGL context is established on the application server's X display, VirtualGL gets out of the way and allows all subsequent OpenGL commands to pass through unimpeded to the application server's 3D hardware. Thus, the application can automatically use whatever OpenGL features and extensions are provided by the application server's hardware and drivers.
Apart from marshaling GLX commands and managing Pbuffers, VirtualGL also reads back the rendered pixels at the appropriate time (usually by monitoring glXSwapBuffers() or glFinish()) and then draws those pixels into application's X window using standard X image drawing commands. Since VirtualGL is redirecting the GLX commands away from the destination X display, it can be used to add accelerated 3D support to X proxies (such as VNC) as well as to prevent indirect OpenGL rendering from occurring when using a remote X display.
Using VirtualGL in concert with VNC or another X proxy allows multiple users to simultaneously run 3D applications on a single application server and multiple clients to share each session. However, VNC and its ilk are tuned to handle 2D applications with large areas of solid color, few colors, and few inter-frame differences. 3D applications, on the other hand, generate images with fine-grained, complex color patterns and much less correlation between subsequent frames. The workload generated by drawing rendered images from an OpenGL application into an X window is essentially the same workload as a video player, and off-the-shelf thin client software typically lacks sufficiently fast image codecs to be able to handle this workload with interactive frame rates.
VirtualGL works around this problem in two ways:

TurboVNC is an offshoot of TightVNC which accelerates the Tight and JPEG encoding paths of the latter, in part by taking advantage of hand-tuned multimedia primitives from Intel and Sun Microsystems. On 100 Megabit ethernet networks, TurboVNC is capable of displaying full-screen (1280x1024-pixel) images with perceptually lossless image quality at greater than 20 frames/second. TurboVNC includes further optimizations which allow it to display full-screen images at 7-10 frames/second over broadband, with noticeable but usable image quality loss. TurboVNC also extends TightVNC to include client-side double buffering and optimized binaries for Solaris. TurboVNC and VirtualGL are used by the Texas Academic Computing Center at UT to allow users of the TeraGrid to remotely access the 3D rendering capabilities of the Maverick terascale visualization supercomputer.

When using the VGL Image Transport, VirtualGL compresses the rendered 3D images in process using the same optimized JPEG codec that TurboVNC uses. VirtualGL then sends the compressed images over a dedicated TCP socket to a VirtualGL Client application running on the client machine. The VirtualGL Client is responsible for decompressing the images and drawing the pixels into the appropriate X window. Meanwhile, the non-OpenGL elements of the application's display are sent over the network using the standard remote X11 protocol and rendered on the client machine.
This approach requires that an X display be present on the client machine, and the reliance upon the remote X11 protocol for performing 2D rendering means that many applications will perform poorly when using the VGL Image Transport on high-latency networks. Additionally, the VGL Image Transport does not inherently support collaboration (multiple clients per session), since the images are being pushed to the users' machines rather than being pulled. But the use of the VGL Image Transport does provide a completely seamless application experience, whereby every application window corresponds to a single desktop window. The VGL Image Transport also reduces the server CPU load, since the 2D rendering is occurring on the client, and the VGL Image Transport allows advanced OpenGL features, such as quad-buffered stereo, to be used.
The developers of VirtualGL envision the primary users of the VGL Image Transport to be laptop users with an 802.11g wireless or a fast ethernet connection to the application server.

VirtualGL and TurboVNC are core components of the Sun Visualization System product from Sun Microsystems. The two open source packages are combined with a closed source plugin that allows VirtualGL to send compressed images to Sun Ray thin clients and another closed source package that integrates VirtualGL with Sun Grid Engine, providing resource management and scheduling for remote 3D jobs. The combination of these packages, dubbed "Sun Shared Visualization", is available as a free download (Sun charges for support.)
v2.1 of the Scalable Visualization Array software from HP also includes components which integrate with VirtualGL and TurboVNC, allowing 3D jobs to be scheduled on and remotely displayed from a visualization cluster.


